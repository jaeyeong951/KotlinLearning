# Kotlin 1.

# 코틀린의 특성

## 함수형 프로그래밍

### 1급 시민(first-class) 함수

- 함수(행동을 나타내는 코드 조각)를 일반 값처럼 다룰 수 있다.
- 함수를 변수에 저장하거나, 함수를 인자로 다른 함수에 전달할 수 있다.
- first-class란?
    - 3가지 조건을 만족하는 객체
    - 함수에 매개변수로 넘길 수 있다.
    - 함수의 반환값이 될 수 있다.
    - 변수로서 할당이 될 수 있다.
- 우리가 그동안 자연스레 써온 대부분의 변수(Integer, String ...)는 모두 1급 객체.
- 코틀린에서는 함수도 1급 객체이다.(자바는 아님) → 함수가 매개변수가 되며, 반환값이 되고, 할당의 대상이 될 수 있다.

[자바 Lambda](Kotlin%201%20f400556a196f42df988e5d7133161870/%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20Lambda%205a2955e6661f4d39aba8d53423f143e3.md)

### 불변성(immutability)

- 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용한다.

### 순수 함수(pure function) = 부수 효과(side effect) 없음

- 입력이 같으면 항상 같은 출력을 내놓는다.
- 다른 객체의 상태를 변경하지 않는다.
- 함수 외부나 다른 바깥 환경과 상호작용하지 않는다.

### 위와 같은 개념을 사용하면 뭐가 좋을까?

1. 간결성
- 순수 함수를 값처럼 화용할 수 있으면 더 강력한 추상화가 가능하다. → 코드 중복을 막는다.
- 예를 들어 아주 비슷한 작업을 수행하는 비슷한 두 개의 코드 조각이 있다고 가정. 이런 경우 로직에서 공통부분을 따로 함수로 뽑아내고 서로 다른 부분만 인자로 전달할 수 있다.

`fun findAlice() = findPerson { [it.name](http://it.name) == "Alice" }` → findPerson에는 사람을 찾는 일반적인 로직이 들어가 있다.

`fun findBob() = findPerson{ [it.name](http://it.name) == "Bob" }`

2. 다중 스레드를 사용해도 안전(safe - multithreding)

- 일반적으로 다중 스레드 프로그램에선 적절한 동기화 없이 같은 데이터를 여러 스레드가 변경하면 많은 문제가 발생
- 하지만 **불변 객체**를 사용하고 **순수 함수**를 그 구조에 적용한다면 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없다.
- 따라서 복잡한 동기화 작업이 필요 없다.

3. 테스트가 쉽다.

- 부수 효과가 존재하는 함수는 테스트에 준비 코드가 필요
- 하지만 순수 함수는 필요없다.

함수형 프로그래밍은 스타일이다. 자바로도 함수형 프로그래밍이 가능하다. 하지만 모든 언어가 함수형 프로그래밍을 편하게 사용하기에 충분한 라이브러리와 문법 지원을 제공하지는 않는다. 코틀린은 처음부터 함수형 프로그래밍을 풍부하게 지원해 왔다. 

코틀린은 함수형  프로그래밍 스타일로 프로그램을 짤 수 있게 지원한다.

하지만 함수형 프로그래밍 스타일을 강제하지는 않는다.

개발자 본인이 생각하기에 명령형 방식이 더 적합한 경우라면 굳이 함수형 프로그래밍 스타일로 번거롭게 코드를 작성할 필요 없이 변경 가능한 데이터와 부수 효과를 활용하는 함수를 사용해도 된다.

코틀린으로 코드를 작성할 때는 객체지향과 함수형 접근 방법을 함께 조합해서 문제에 가장 적합한 도구를 그때 그때 판단하여 사용하자.

안드로이드 애플리케이션을 개발함에 있어서도 코틀린은 상당한 강점이 있다. 

안드로이드 개발을 해 본 사람이라면 NullPointerException을 많이 마주했을 것이다. 코틀린 타입 시스템은 null 값을 정확히 추적하며 널 포인터로 인해 생기는 문제를 줄여준다. 자바에서 NullPointerException을 일으키는 유형의 코드는 대부분 코틀린에서는 컴파일도 되지 않는다.

코틀린을 사용하더라도 성능 측명에서 아무런 손해가 없다. 코틀린 컴파일러가 생성한 바이트코드는 일반적인 자바 코드가 생성한 바이트코드와 똑같이 효율적으로 실행된다.

코틀린의 런타임 시스템은 상당히 작기 때문에 컴파일 후 패키징한 애플리케이션 크기도 자바 애플리케이션과 비교했을 때 차이가 없다.

또한 대부분의 코틀린 표준 라이브러리 함수는 인자로 받은 람다 함수를 인라이닝(inlining)한다. → 람다를 사용해도 새로운 객체가 만들어지지 않으므로 객체 증가로 인한 가비지 컬렉션이 없다.